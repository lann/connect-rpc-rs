// @generated
// This file is @generated by prost-build.
/// Config defines the configuration for running conformance tests.
/// This enumerates all of the "flavors" of the test suite to run.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    /// The features supported by the client or server under test.
    /// This is used to filter the set of test cases that are run.
    /// If absent, an empty message is used. See Features for more
    /// on how empty/absent fields are interpreted.
    #[prost(message, optional, tag="1")]
    pub features: ::core::option::Option<Features>,
    /// This can indicate additional permutations that are supported
    /// that might otherwise be excluded based on the above features.
    #[prost(message, repeated, tag="2")]
    pub include_cases: ::prost::alloc::vec::Vec<ConfigCase>,
    /// This can indicates permutations that are not supported even
    /// though their support might be implied by the above features.
    #[prost(message, repeated, tag="3")]
    pub exclude_cases: ::prost::alloc::vec::Vec<ConfigCase>,
}
/// Features define the feature set that a client or server supports. They are
/// used to determine the server configurations and test cases that
/// will be run. They are defined in YAML files and are specified as part of the
/// --conf flag to the test runner.
///
/// TODO: we could probably model some of the constraints on what are valid vs.
///        invalid (i.e. conflicting/impossible) features using protovalidate rules
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Features {
    /// Supported HTTP versions.
    /// If empty, HTTP 1.1 and HTTP/2 are assumed.
    #[prost(enumeration="HttpVersion", repeated, tag="1")]
    pub versions: ::prost::alloc::vec::Vec<i32>,
    /// Supported protocols.
    /// If empty, all three are assumed: Connect, gRPC, and gRPC-Web.
    #[prost(enumeration="Protocol", repeated, tag="2")]
    pub protocols: ::prost::alloc::vec::Vec<i32>,
    /// Supported codecs.
    /// If empty, "proto" and "json" are assumed.
    #[prost(enumeration="Codec", repeated, tag="3")]
    pub codecs: ::prost::alloc::vec::Vec<i32>,
    /// Supported compression algorithms.
    /// If empty, "identity" and "gzip" are assumed.
    #[prost(enumeration="Compression", repeated, tag="4")]
    pub compressions: ::prost::alloc::vec::Vec<i32>,
    /// Supported stream types.
    /// If empty, all stream types are assumed. This is usually for
    /// clients, since some client environments may not be able to
    /// support certain kinds of streaming operations, especially
    /// bidirectional streams.
    #[prost(enumeration="StreamType", repeated, tag="5")]
    pub stream_types: ::prost::alloc::vec::Vec<i32>,
    /// Whether H2C (unencrypted, non-TLS HTTP/2 over cleartext) is supported.
    /// If absent, true is assumed.
    #[prost(bool, optional, tag="6")]
    pub supports_h2c: ::core::option::Option<bool>,
    /// Whether TLS is supported.
    /// If absent, true is assumed.
    #[prost(bool, optional, tag="7")]
    pub supports_tls: ::core::option::Option<bool>,
    /// Whether the client supports TLS certificates.
    /// If absent, false is assumed. This should not be set if
    /// supports_tls is false.
    #[prost(bool, optional, tag="8")]
    pub supports_tls_client_certs: ::core::option::Option<bool>,
    /// Whether trailers are supported.
    /// If absent, true is assumed. If false, implies that gRPC protocol is not allowed.
    #[prost(bool, optional, tag="9")]
    pub supports_trailers: ::core::option::Option<bool>,
    /// Whether half duplex bidi streams are supported over HTTP/1.1.
    /// If absent, false is assumed.
    #[prost(bool, optional, tag="10")]
    pub supports_half_duplex_bidi_over_http1: ::core::option::Option<bool>,
    /// Whether Connect via GET is supported.
    /// If absent, true is assumed.
    #[prost(bool, optional, tag="11")]
    pub supports_connect_get: ::core::option::Option<bool>,
    /// Whether a message receive limit is supported.
    /// If absent, true is assumed.
    #[prost(bool, optional, tag="12")]
    pub supports_message_receive_limit: ::core::option::Option<bool>,
}
/// ConfigCase represents a single resolved configuration case. When tests are
/// run, the Config and the supported features therein are used to compute all
/// of the cases relevant to the implementation under test. These configuration
/// cases are then used to select which test cases are applicable.
///
/// TODO: we could probably model some of the constraints on what is a valid
///        vs. invalid config case using protovalidate rules
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigCase {
    /// If unspecified, indicates cases for all versions.
    #[prost(enumeration="HttpVersion", tag="1")]
    pub version: i32,
    /// If unspecified, indicates cases for all protocols.
    #[prost(enumeration="Protocol", tag="2")]
    pub protocol: i32,
    /// If unspecified, indicates cases for all codecs.
    #[prost(enumeration="Codec", tag="3")]
    pub codec: i32,
    /// If unspecified, indicates cases for all compression algorithms.
    #[prost(enumeration="Compression", tag="4")]
    pub compression: i32,
    /// If unspecified, indicates cases for all stream types.
    #[prost(enumeration="StreamType", tag="5")]
    pub stream_type: i32,
    /// If absent, indicates cases for plaintext (no TLS) but also for
    /// TLS if features indicate that TLS is supported.
    #[prost(bool, optional, tag="6")]
    pub use_tls: ::core::option::Option<bool>,
    /// If absent, indicates cases without client certs but also cases
    /// that use client certs if features indicate they are supported.
    #[prost(bool, optional, tag="7")]
    pub use_tls_client_certs: ::core::option::Option<bool>,
    /// If absent, indicates cases that do not test message receive
    /// limits but also cases that do test message receive limits if
    /// features indicate they are supported.
    #[prost(bool, optional, tag="8")]
    pub use_message_receive_limit: ::core::option::Option<bool>,
}
/// TLSCreds represents credentials for TLS. It includes both a
/// certificate and corresponding private key. Both are encoded
/// in PEM format.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TlsCreds {
    #[prost(bytes="vec", tag="1")]
    pub cert: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HttpVersion {
    Unspecified = 0,
    HttpVersion1 = 1,
    HttpVersion2 = 2,
    HttpVersion3 = 3,
}
impl HttpVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HttpVersion::Unspecified => "HTTP_VERSION_UNSPECIFIED",
            HttpVersion::HttpVersion1 => "HTTP_VERSION_1",
            HttpVersion::HttpVersion2 => "HTTP_VERSION_2",
            HttpVersion::HttpVersion3 => "HTTP_VERSION_3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HTTP_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "HTTP_VERSION_1" => Some(Self::HttpVersion1),
            "HTTP_VERSION_2" => Some(Self::HttpVersion2),
            "HTTP_VERSION_3" => Some(Self::HttpVersion3),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Protocol {
    Unspecified = 0,
    Connect = 1,
    Grpc = 2,
    /// TODO: Support add'l protocols:
    /// PROTOCOL_GRPC_WEB_TEXT = 4;
    /// PROTOCOL_REST_TRANSCODING = 5;
    GrpcWeb = 3,
}
impl Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Protocol::Unspecified => "PROTOCOL_UNSPECIFIED",
            Protocol::Connect => "PROTOCOL_CONNECT",
            Protocol::Grpc => "PROTOCOL_GRPC",
            Protocol::GrpcWeb => "PROTOCOL_GRPC_WEB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
            "PROTOCOL_CONNECT" => Some(Self::Connect),
            "PROTOCOL_GRPC" => Some(Self::Grpc),
            "PROTOCOL_GRPC_WEB" => Some(Self::GrpcWeb),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Codec {
    Unspecified = 0,
    Proto = 1,
    Json = 2,
    /// not used; will be ignored
    Text = 3,
}
impl Codec {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Codec::Unspecified => "CODEC_UNSPECIFIED",
            Codec::Proto => "CODEC_PROTO",
            Codec::Json => "CODEC_JSON",
            Codec::Text => "CODEC_TEXT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CODEC_UNSPECIFIED" => Some(Self::Unspecified),
            "CODEC_PROTO" => Some(Self::Proto),
            "CODEC_JSON" => Some(Self::Json),
            "CODEC_TEXT" => Some(Self::Text),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Compression {
    Unspecified = 0,
    Identity = 1,
    Gzip = 2,
    Br = 3,
    Zstd = 4,
    Deflate = 5,
    Snappy = 6,
}
impl Compression {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Compression::Unspecified => "COMPRESSION_UNSPECIFIED",
            Compression::Identity => "COMPRESSION_IDENTITY",
            Compression::Gzip => "COMPRESSION_GZIP",
            Compression::Br => "COMPRESSION_BR",
            Compression::Zstd => "COMPRESSION_ZSTD",
            Compression::Deflate => "COMPRESSION_DEFLATE",
            Compression::Snappy => "COMPRESSION_SNAPPY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPRESSION_IDENTITY" => Some(Self::Identity),
            "COMPRESSION_GZIP" => Some(Self::Gzip),
            "COMPRESSION_BR" => Some(Self::Br),
            "COMPRESSION_ZSTD" => Some(Self::Zstd),
            "COMPRESSION_DEFLATE" => Some(Self::Deflate),
            "COMPRESSION_SNAPPY" => Some(Self::Snappy),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamType {
    Unspecified = 0,
    Unary = 1,
    ClientStream = 2,
    ServerStream = 3,
    HalfDuplexBidiStream = 4,
    FullDuplexBidiStream = 5,
}
impl StreamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StreamType::Unspecified => "STREAM_TYPE_UNSPECIFIED",
            StreamType::Unary => "STREAM_TYPE_UNARY",
            StreamType::ClientStream => "STREAM_TYPE_CLIENT_STREAM",
            StreamType::ServerStream => "STREAM_TYPE_SERVER_STREAM",
            StreamType::HalfDuplexBidiStream => "STREAM_TYPE_HALF_DUPLEX_BIDI_STREAM",
            StreamType::FullDuplexBidiStream => "STREAM_TYPE_FULL_DUPLEX_BIDI_STREAM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STREAM_TYPE_UNARY" => Some(Self::Unary),
            "STREAM_TYPE_CLIENT_STREAM" => Some(Self::ClientStream),
            "STREAM_TYPE_SERVER_STREAM" => Some(Self::ServerStream),
            "STREAM_TYPE_HALF_DUPLEX_BIDI_STREAM" => Some(Self::HalfDuplexBidiStream),
            "STREAM_TYPE_FULL_DUPLEX_BIDI_STREAM" => Some(Self::FullDuplexBidiStream),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Code {
    Unspecified = 0,
    Canceled = 1,
    Unknown = 2,
    InvalidArgument = 3,
    DeadlineExceeded = 4,
    NotFound = 5,
    AlreadyExists = 6,
    PermissionDenied = 7,
    ResourceExhausted = 8,
    FailedPrecondition = 9,
    Aborted = 10,
    OutOfRange = 11,
    Unimplemented = 12,
    Internal = 13,
    Unavailable = 14,
    DataLoss = 15,
    Unauthenticated = 16,
}
impl Code {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Code::Unspecified => "CODE_UNSPECIFIED",
            Code::Canceled => "CODE_CANCELED",
            Code::Unknown => "CODE_UNKNOWN",
            Code::InvalidArgument => "CODE_INVALID_ARGUMENT",
            Code::DeadlineExceeded => "CODE_DEADLINE_EXCEEDED",
            Code::NotFound => "CODE_NOT_FOUND",
            Code::AlreadyExists => "CODE_ALREADY_EXISTS",
            Code::PermissionDenied => "CODE_PERMISSION_DENIED",
            Code::ResourceExhausted => "CODE_RESOURCE_EXHAUSTED",
            Code::FailedPrecondition => "CODE_FAILED_PRECONDITION",
            Code::Aborted => "CODE_ABORTED",
            Code::OutOfRange => "CODE_OUT_OF_RANGE",
            Code::Unimplemented => "CODE_UNIMPLEMENTED",
            Code::Internal => "CODE_INTERNAL",
            Code::Unavailable => "CODE_UNAVAILABLE",
            Code::DataLoss => "CODE_DATA_LOSS",
            Code::Unauthenticated => "CODE_UNAUTHENTICATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "CODE_CANCELED" => Some(Self::Canceled),
            "CODE_UNKNOWN" => Some(Self::Unknown),
            "CODE_INVALID_ARGUMENT" => Some(Self::InvalidArgument),
            "CODE_DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
            "CODE_NOT_FOUND" => Some(Self::NotFound),
            "CODE_ALREADY_EXISTS" => Some(Self::AlreadyExists),
            "CODE_PERMISSION_DENIED" => Some(Self::PermissionDenied),
            "CODE_RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
            "CODE_FAILED_PRECONDITION" => Some(Self::FailedPrecondition),
            "CODE_ABORTED" => Some(Self::Aborted),
            "CODE_OUT_OF_RANGE" => Some(Self::OutOfRange),
            "CODE_UNIMPLEMENTED" => Some(Self::Unimplemented),
            "CODE_INTERNAL" => Some(Self::Internal),
            "CODE_UNAVAILABLE" => Some(Self::Unavailable),
            "CODE_DATA_LOSS" => Some(Self::DataLoss),
            "CODE_UNAUTHENTICATED" => Some(Self::Unauthenticated),
            _ => None,
        }
    }
}
/// A definition of a response to be sent from a single-response endpoint.
/// Can be used to define a response for unary or client-streaming calls.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnaryResponseDefinition {
    /// Response headers to send
    #[prost(message, repeated, tag="1")]
    pub response_headers: ::prost::alloc::vec::Vec<Header>,
    /// Response trailers to send - together with the error if present
    #[prost(message, repeated, tag="4")]
    pub response_trailers: ::prost::alloc::vec::Vec<Header>,
    /// Wait this many milliseconds before sending a response message
    #[prost(uint32, tag="6")]
    pub response_delay_ms: u32,
    /// This field is only used by the reference server. If you are implementing a
    /// server under test, you can ignore this field or respond with an error if the
    /// server receives a request where it is set.
    ///
    /// For test definitions, this field should be used instead of the above fields.
    #[prost(message, optional, tag="5")]
    pub raw_response: ::core::option::Option<RawHttpResponse>,
    #[prost(oneof="unary_response_definition::Response", tags="2, 3")]
    pub response: ::core::option::Option<unary_response_definition::Response>,
}
/// Nested message and enum types in `UnaryResponseDefinition`.
pub mod unary_response_definition {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        /// Response data to send
        #[prost(bytes, tag="2")]
        ResponseData(::prost::alloc::vec::Vec<u8>),
        /// Error to raise instead of response message
        /// Servers should build a RequestInfo and append it to the details of the
        /// requested error.
        #[prost(message, tag="3")]
        Error(super::Error),
    }
}
/// A definition of responses to be sent from a streaming endpoint.
/// Can be used to define responses for server-streaming or bidi-streaming calls.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamResponseDefinition {
    /// Response headers to send
    #[prost(message, repeated, tag="1")]
    pub response_headers: ::prost::alloc::vec::Vec<Header>,
    /// Response data to send
    #[prost(bytes="vec", repeated, tag="2")]
    pub response_data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Wait this many milliseconds before sending each response message
    #[prost(uint32, tag="3")]
    pub response_delay_ms: u32,
    /// Optional error to raise, but only after sending any response messages.
    /// In the event an immediate error is thrown before any responses are sent,
    /// (i.e. the equivalent of a trailers-only response), then servers should
    /// build a RequestInfo message with available information and append that to
    /// the error details.
    #[prost(message, optional, tag="4")]
    pub error: ::core::option::Option<Error>,
    /// Response trailers to send - together with the error if present
    #[prost(message, repeated, tag="5")]
    pub response_trailers: ::prost::alloc::vec::Vec<Header>,
    /// This field is only used by the reference server. If you are implementing a
    /// server under test, you can ignore this field or respond with an error if the
    /// server receives a request where it is set.
    ///
    /// For test definitions, this field should be used instead of the above fields.
    #[prost(message, optional, tag="6")]
    pub raw_response: ::core::option::Option<RawHttpResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnaryRequest {
    /// The response definition which should be returned in the conformance payload
    #[prost(message, optional, tag="1")]
    pub response_definition: ::core::option::Option<UnaryResponseDefinition>,
    /// Additional data. Only used to pad the request size to test large request messages.
    #[prost(bytes="vec", tag="2")]
    pub request_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnaryResponse {
    /// The conformance payload to respond with.
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<ConformancePayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdempotentUnaryRequest {
    /// The response definition which should be returned in the conformance payload
    #[prost(message, optional, tag="1")]
    pub response_definition: ::core::option::Option<UnaryResponseDefinition>,
    /// Additional data. Only used to pad the request size to test large request messages.
    #[prost(bytes="vec", tag="2")]
    pub request_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdempotentUnaryResponse {
    /// The conformance payload to respond with.
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<ConformancePayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerStreamRequest {
    /// The response definition which should be returned in the conformance payload.
    #[prost(message, optional, tag="1")]
    pub response_definition: ::core::option::Option<StreamResponseDefinition>,
    /// Additional data. Only used to pad the request size to test large request messages.
    #[prost(bytes="vec", tag="2")]
    pub request_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerStreamResponse {
    /// The conformance payload to respond with
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<ConformancePayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientStreamRequest {
    /// Tells the server how to reply once all client messages are
    /// complete. Required in the first message in the stream, but
    /// should be ignored in subsequent messages.
    #[prost(message, optional, tag="1")]
    pub response_definition: ::core::option::Option<UnaryResponseDefinition>,
    /// Additional data for subsequent messages in the stream. Also
    /// used to pad the request size to test large request messages.
    #[prost(bytes="vec", tag="2")]
    pub request_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientStreamResponse {
    /// The conformance payload to respond with
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<ConformancePayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiStreamRequest {
    /// Tells the server how to reply; required in the first message
    /// in the stream. Should be ignored in subsequent messages.
    #[prost(message, optional, tag="1")]
    pub response_definition: ::core::option::Option<StreamResponseDefinition>,
    /// Tells the server whether it should wait for each request
    /// before sending a response.
    ///
    /// If true, it indicates the server should effectively interleave the
    /// stream so messages are sent in request->response pairs.
    ///
    /// If false, then the response stream will be sent once all request messages
    /// are finished sending with the only delays between messages
    /// being the optional fixed milliseconds defined in the response
    /// definition.
    ///
    /// This field is only relevant in the first message in the stream
    /// and should be ignored in subsequent messages.
    #[prost(bool, tag="2")]
    pub full_duplex: bool,
    /// Additional data for subsequent messages in the stream. Also
    /// used to pad the request size to test large request messages.
    #[prost(bytes="vec", tag="3")]
    pub request_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiStreamResponse {
    /// The conformance payload to respond with
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<ConformancePayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnimplementedRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnimplementedResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConformancePayload {
    /// Any response data specified in the response definition to the server should be
    /// echoed back here.
    #[prost(bytes="vec", tag="1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Echoes back information about the request stream observed so far.
    #[prost(message, optional, tag="2")]
    pub request_info: ::core::option::Option<conformance_payload::RequestInfo>,
}
/// Nested message and enum types in `ConformancePayload`.
pub mod conformance_payload {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RequestInfo {
        /// The server echos back the request headers it observed here.
        #[prost(message, repeated, tag="1")]
        pub request_headers: ::prost::alloc::vec::Vec<super::Header>,
        /// The timeout observed that was included in the request. Other timeouts use a
        /// type of uint32, but we want to be lenient here to allow whatever value the RPC
        /// server observes, even if it's outside the range of uint32.
        #[prost(int64, optional, tag="2")]
        pub timeout_ms: ::core::option::Option<i64>,
        /// The server should echo back all requests received.
        /// For unary and server-streaming requests, this should always contain a single request
        /// For client-streaming and half-duplex bidi-streaming, this should contain
        /// all client requests in the order received and be present in each response.
        /// For full-duplex bidirectional-streaming, this should contain all requests in the order
        /// they were received since the last sent response.
        #[prost(message, repeated, tag="3")]
        pub requests: ::prost::alloc::vec::Vec<::prost_types::Any>,
        /// If present, the request used the Connect protocol and a GET method. This
        /// captures other relevant information about the request. If a server implementation
        /// is unable to populate this (due to the server framework not exposing all of these
        /// details to application code), it may be an empty message. This implies that the
        /// server framework, at a minimum, at least expose to application code whether the
        /// request used GET vs. POST.
        #[prost(message, optional, tag="4")]
        pub connect_get_info: ::core::option::Option<ConnectGetInfo>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConnectGetInfo {
        /// The query params observed in the request URL.
        #[prost(message, repeated, tag="1")]
        pub query_params: ::prost::alloc::vec::Vec<super::Header>,
    }
}
/// An error definition used for specifying a desired error response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    /// The error code.
    /// For a list of Connect error codes see: <https://connectrpc.com/docs/protocol#error-codes>
    #[prost(enumeration="Code", tag="1")]
    pub code: i32,
    /// If this value is absent in a test case response definition, the contents of the
    /// actual error message will not be checked. This is useful for certain kinds of
    /// error conditions where the exact message to be used is not specified, only the
    /// code.
    #[prost(string, optional, tag="2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// Errors in Connect and gRPC protocols can have arbitrary messages
    /// attached to them, which are known as error details.
    #[prost(message, repeated, tag="3")]
    pub details: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
/// A tuple of name and values (ASCII) for a header or trailer entry.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    /// Header/trailer name (key).
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Header/trailer value. This is repeated to explicitly support headers and
    /// trailers where a key is repeated. In such a case, these values must be in
    /// the same order as which values appeared in the header or trailer block.
    #[prost(string, repeated, tag="2")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// RawHTTPRequest models a raw HTTP request. This can be used to craft
/// custom requests with odd properties (including certain kinds of
/// malformed requests) to test edge cases in servers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawHttpRequest {
    /// The HTTP verb (i.e. GET , POST).
    #[prost(string, tag="1")]
    pub verb: ::prost::alloc::string::String,
    /// The URI to send the request to.
    #[prost(string, tag="2")]
    pub uri: ::prost::alloc::string::String,
    /// Any headers to set on the request.
    #[prost(message, repeated, tag="3")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// These query params will be encoded and added to the uri before
    /// the request is sent.
    #[prost(message, repeated, tag="4")]
    pub raw_query_params: ::prost::alloc::vec::Vec<Header>,
    /// This provides an easier way to define a complex binary query param
    /// than having to write literal base64-encoded bytes in raw_query_params.
    #[prost(message, repeated, tag="5")]
    pub encoded_query_params: ::prost::alloc::vec::Vec<raw_http_request::EncodedQueryParam>,
    #[prost(oneof="raw_http_request::Body", tags="6, 7")]
    pub body: ::core::option::Option<raw_http_request::Body>,
}
/// Nested message and enum types in `RawHTTPRequest`.
pub mod raw_http_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EncodedQueryParam {
        /// Query param name.
        #[prost(string, tag="1")]
        pub name: ::prost::alloc::string::String,
        /// Query param value.
        #[prost(message, optional, tag="2")]
        pub value: ::core::option::Option<super::MessageContents>,
        /// If true, the message contents will be base64-encoded and the
        /// resulting string used as the query parameter value.
        #[prost(bool, tag="3")]
        pub base64_encode: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Body {
        /// The body is a single message.
        #[prost(message, tag="6")]
        Unary(super::MessageContents),
        /// The body is a stream, encoded using a five-byte
        /// prefix before each item in the stream.
        #[prost(message, tag="7")]
        Stream(super::StreamContents),
    }
}
/// MessageContents represents a message in a request body.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContents {
    /// If specified and not identity, the above data will be
    /// compressed using the given algorithm.
    #[prost(enumeration="Compression", tag="4")]
    pub compression: i32,
    /// The message data can be defined in one of three ways.
    #[prost(oneof="message_contents::Data", tags="1, 2, 3")]
    pub data: ::core::option::Option<message_contents::Data>,
}
/// Nested message and enum types in `MessageContents`.
pub mod message_contents {
    /// The message data can be defined in one of three ways.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// Arbitrary bytes.
        #[prost(bytes, tag="1")]
        Binary(::prost::alloc::vec::Vec<u8>),
        /// Arbitrary text.
        #[prost(string, tag="2")]
        Text(::prost::alloc::string::String),
        /// An actual message. The message inside the Any will be
        /// serialized to the protobuf binary formats, and the
        /// resulting bytes will be the contents.
        #[prost(message, tag="3")]
        BinaryMessage(::prost_types::Any),
    }
}
/// StreamContents represents a sequence of messages in a request body.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamContents {
    /// The messages in the stream.
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<stream_contents::StreamItem>,
}
/// Nested message and enum types in `StreamContents`.
pub mod stream_contents {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StreamItem {
        /// must be in the range 0 to 255.
        #[prost(uint32, tag="1")]
        pub flags: u32,
        /// if absent use actual length of payload
        #[prost(uint32, optional, tag="2")]
        pub length: ::core::option::Option<u32>,
        #[prost(message, optional, tag="3")]
        pub payload: ::core::option::Option<super::MessageContents>,
    }
}
/// RawHTTPResponse models a raw HTTP response. This can be used to craft
/// custom responses with odd properties (including certain kinds of
/// malformed responses) to test edge cases in clients.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawHttpResponse {
    /// If status code is not specified, it will default to a 200 response code.
    #[prost(uint32, tag="1")]
    pub status_code: u32,
    /// Headers to be set on the response.
    #[prost(message, repeated, tag="2")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// Trailers to be set on the response.
    #[prost(message, repeated, tag="5")]
    pub trailers: ::prost::alloc::vec::Vec<Header>,
    #[prost(oneof="raw_http_response::Body", tags="3, 4")]
    pub body: ::core::option::Option<raw_http_response::Body>,
}
/// Nested message and enum types in `RawHTTPResponse`.
pub mod raw_http_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Body {
        /// The body is a single message.
        #[prost(message, tag="3")]
        Unary(super::MessageContents),
        /// The body is a stream, encoded using a five-byte
        /// prefix before each item in the stream.
        #[prost(message, tag="4")]
        Stream(super::StreamContents),
    }
}
/// Describes one call the client should make. The client reads
/// these from stdin and, for each one, invokes an RPC as directed
/// and writes the results (in the form of a ClientCompatResponse
/// message) to stdout.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientCompatRequest {
    /// The name of the test that this request is performing.
    /// When writing test cases, this is a required field.
    #[prost(string, tag="1")]
    pub test_name: ::prost::alloc::string::String,
    /// Test suite YAML definitions should NOT set values for these next
    /// nine fields (fields 2 - 10). They are automatically populated by the test
    /// runner. If a test is specific to one of these values, it should instead be
    /// indicated in the test suite itself (where it defines the required
    /// features and relevant values for these fields).
    ///
    /// The HTTP version to use for the test (i.e. HTTP/1.1, HTTP/2, HTTP/3).
    #[prost(enumeration="HttpVersion", tag="2")]
    pub http_version: i32,
    /// The protocol to use for the test (i.e. Connect, gRPC, gRPC-web).
    #[prost(enumeration="Protocol", tag="3")]
    pub protocol: i32,
    /// The codec to use for the test (i.e. JSON, proto/binary).
    #[prost(enumeration="Codec", tag="4")]
    pub codec: i32,
    /// The compression to use for the test (i.e. brotli, gzip, identity).
    #[prost(enumeration="Compression", tag="5")]
    pub compression: i32,
    /// The server host that this request will be sent to.
    #[prost(string, tag="6")]
    pub host: ::prost::alloc::string::String,
    /// The server port that this request will be sent to.
    #[prost(uint32, tag="7")]
    pub port: u32,
    /// If non-empty, the server is using TLS. The bytes are the
    /// server's PEM-encoded certificate, which the client should
    /// verify and trust.
    #[prost(bytes="vec", tag="8")]
    pub server_tls_cert: ::prost::alloc::vec::Vec<u8>,
    /// If present, the client certificate credentials to use to
    /// authenticate with the server. This will only be present
    /// when server_tls_cert is non-empty.
    #[prost(message, optional, tag="9")]
    pub client_tls_creds: ::core::option::Option<TlsCreds>,
    /// If non-zero, indicates the maximum size in bytes for a message.
    /// If the server sends anything larger, the client should reject it.
    #[prost(uint32, tag="10")]
    pub message_receive_limit: u32,
    /// The fully-qualified name of the service this test will interact with.
    /// If specified, method must also be specified.
    /// If not specified, defaults to "connectrpc.conformance.v1.ConformanceService".
    #[prost(string, optional, tag="11")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    /// The method on `service` that will be called.
    /// If specified, service must also be specified.
    /// If not specified, the test runner will auto-populate this field based on the stream_type.
    #[prost(string, optional, tag="12")]
    pub method: ::core::option::Option<::prost::alloc::string::String>,
    /// The stream type of `method` (i.e. unary, client stream, server stream, full-duplex bidi
    /// stream, or half-duplex bidi stream).
    /// When writing test cases, this is a required field.
    #[prost(enumeration="StreamType", tag="13")]
    pub stream_type: i32,
    /// If protocol indicates Connect and stream type indicates
    /// Unary, this instructs the client to use a GET HTTP method
    /// when making the request.
    #[prost(bool, tag="14")]
    pub use_get_http_method: bool,
    /// Any request headers that should be sent as part of the request.
    /// These include only custom header metadata. Headers that are
    /// part of the relevant protocol (such as "content-type", etc) should
    /// not be stated here.
    #[prost(message, repeated, tag="15")]
    pub request_headers: ::prost::alloc::vec::Vec<Header>,
    /// The actual request messages that will sent to the server.
    /// The type URL for all entries should be equal to the request type of the
    /// method.
    /// There must be exactly one for unary and server stream methods but
    /// can be zero or more for client and bidi stream methods.
    /// For client and bidi stream methods, all entries will have the
    /// same type URL.
    #[prost(message, repeated, tag="16")]
    pub request_messages: ::prost::alloc::vec::Vec<::prost_types::Any>,
    /// The timeout, in milliseconds, for the request. This is equivalent to a
    /// deadline for the request. If unset, there will be no timeout.
    #[prost(uint32, optional, tag="17")]
    pub timeout_ms: ::core::option::Option<u32>,
    /// Wait this many milliseconds before sending a request message.
    /// For client or bidi stream methods, this delay should be
    /// applied before each request sent.
    #[prost(uint32, tag="18")]
    pub request_delay_ms: u32,
    /// If present, the client should cancel the RPC instead of
    /// allowing to complete normally.
    #[prost(message, optional, tag="19")]
    pub cancel: ::core::option::Option<client_compat_request::Cancel>,
    /// The following field is only used by the reference client. If
    /// you are implementing a client under test, you may ignore it
    /// or respond with an error if the client receives a request where
    /// it is set.
    ///
    /// When this field is present, it defines the actual HTTP request
    /// that will be sent. The above group of fields must still be
    /// provided and valid so that the reference client knows how it
    /// should try to interpret the server's response.
    #[prost(message, optional, tag="20")]
    pub raw_request: ::core::option::Option<RawHttpRequest>,
}
/// Nested message and enum types in `ClientCompatRequest`.
pub mod client_compat_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Cancel {
        /// These fields determine the timing of cancellation.
        /// If none are present, the client should cancel immediately
        /// after all request messages are sent and the send side is
        /// closed (as if the after_close_send_ms field were present
        /// and zero).
        #[prost(oneof="cancel::CancelTiming", tags="1, 2, 3")]
        pub cancel_timing: ::core::option::Option<cancel::CancelTiming>,
    }
    /// Nested message and enum types in `Cancel`.
    pub mod cancel {
        /// These fields determine the timing of cancellation.
        /// If none are present, the client should cancel immediately
        /// after all request messages are sent and the send side is
        /// closed (as if the after_close_send_ms field were present
        /// and zero).
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum CancelTiming {
            /// When present, the client should cancel *instead of*
            /// closing the send side of the stream, after all requests
            /// have been sent.
            ///
            /// This applies only to client and bidi stream RPCs.
            #[prost(message, tag="1")]
            BeforeCloseSend(()),
            /// When present, the client should delay for this many
            /// milliseconds after closing the send side of the stream
            /// and then cancel.
            ///
            /// This applies to all types of RPCs.
            ///
            /// For unary and server stream RPCs, where the API usually
            /// does not allow explicitly closing the send side, the
            /// cancellation should be done immediately after invoking
            /// the RPC (which should implicitly send the one-and-only
            /// request and then close the send-side).
            ///
            /// For APIs where unary RPCs block until the response
            /// is received, there is no point after the request is
            /// sent but before a response is received to cancel. So
            /// the client must arrange for the RPC to be canceled
            /// asynchronously before invoking the blocking unary call.
            #[prost(uint32, tag="2")]
            AfterCloseSendMs(u32),
            /// When present, the client should cancel right after
            /// reading this number of response messages from the stream.
            /// When present, this will be greater than zero.
            ///
            /// This applies only to server and bidi stream RPCs.
            #[prost(uint32, tag="3")]
            AfterNumResponses(u32),
        }
    }
}
/// The outcome of one ClientCompatRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientCompatResponse {
    /// The test name that this response applies to.
    #[prost(string, tag="1")]
    pub test_name: ::prost::alloc::string::String,
    /// These fields determine the outcome of the request.
    ///
    /// With regards to errors, any unexpected errors that prevent the client from
    /// issuing the RPC and following the instructions implied by the request can
    /// be reported as an error. These would be errors creating an RPC client from
    /// the request parameters or unsupported/illegal values in the request
    /// (e.g. a unary request that defines zero or multiple request messages).
    ///
    /// However, once the RPC is issued, any resulting error should instead be encoded in response.
    #[prost(oneof="client_compat_response::Result", tags="2, 3")]
    pub result: ::core::option::Option<client_compat_response::Result>,
}
/// Nested message and enum types in `ClientCompatResponse`.
pub mod client_compat_response {
    /// These fields determine the outcome of the request.
    ///
    /// With regards to errors, any unexpected errors that prevent the client from
    /// issuing the RPC and following the instructions implied by the request can
    /// be reported as an error. These would be errors creating an RPC client from
    /// the request parameters or unsupported/illegal values in the request
    /// (e.g. a unary request that defines zero or multiple request messages).
    ///
    /// However, once the RPC is issued, any resulting error should instead be encoded in response.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="2")]
        Response(super::ClientResponseResult),
        #[prost(message, tag="3")]
        Error(super::ClientErrorResult),
    }
}
/// The result of a ClientCompatRequest, which may or may not be successful.
/// The client will build this message and return it back to the test runner.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientResponseResult {
    /// All response headers read from the response.
    #[prost(message, repeated, tag="1")]
    pub response_headers: ::prost::alloc::vec::Vec<Header>,
    /// Servers should echo back payloads that they received as part of the request.
    /// This field should contain all the payloads the server echoed back. Note that
    /// There will be zero-to-one for unary and client stream methods and
    /// zero-to-many for server and bidi stream methods.
    #[prost(message, repeated, tag="2")]
    pub payloads: ::prost::alloc::vec::Vec<ConformancePayload>,
    /// The error received from the actual RPC invocation. Note this is not representative
    /// of a runtime error and should always be the proto equivalent of a Connect
    /// or gRPC error.
    #[prost(message, optional, tag="3")]
    pub error: ::core::option::Option<Error>,
    /// All response headers read from the response.
    #[prost(message, repeated, tag="4")]
    pub response_trailers: ::prost::alloc::vec::Vec<Header>,
    /// The number of messages that were present in the request but that could not be
    /// sent because an error occurred before finishing the upload.
    #[prost(int32, tag="5")]
    pub num_unsent_requests: i32,
    /// The following field is only set by the reference client. It communicates
    /// the underlying HTTP status code of the server's response.
    /// If you are implementing a client-under-test, you should ignore this field
    /// and leave it unset.
    #[prost(int32, optional, tag="6")]
    pub http_status_code: ::core::option::Option<i32>,
    /// This field is used only by the reference client, and it can be used
    /// to provide additional feedback about problems observed in the server
    /// response or in client processing of the response. If non-empty, the test
    /// case is considered failed even if the result above matches all expectations.
    /// If you are implementing a client-under-test, you should ignore this field
    /// and leave it unset.
    #[prost(string, repeated, tag="7")]
    pub feedback: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The client is not able to fulfill the ClientCompatRequest. This may be due
/// to a runtime error or an unexpected internal error such as the requested protocol
/// not being supported. This is completely independent of the actual RPC invocation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientErrorResult {
    /// A message describing the error that occurred. This string will be shown to
    /// users running conformance tests so it should include any relevant details
    /// that may help troubleshoot or remedy the error.
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
}
/// Details about various values as observed on the wire. This message is used
/// only by the reference client when reporting results and should not be populated
/// by clients under test.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WireDetails {
    /// The HTTP status code of the response.
    #[prost(int32, tag="1")]
    pub actual_status_code: i32,
    /// When processing an error from a Connect server, this should contain
    /// the actual JSON received on the wire.
    #[prost(message, optional, tag="2")]
    pub connect_error_raw: ::core::option::Option<::prost_types::Struct>,
    /// Any HTTP trailers observed after the response body. These do NOT
    /// include trailers that conveyed via the body, as done in the gRPC-Web
    /// and Connect streaming protocols.
    #[prost(message, repeated, tag="3")]
    pub actual_http_trailers: ::prost::alloc::vec::Vec<Header>,
    /// Any trailers that were transmitted in the final message of the
    /// response body for a gRPC-Web response. This could differ from the
    /// ClientResponseResult.response_trailers field since the RPC client
    /// library might canonicalize keys and it might choose to remove
    /// "grpc-status" et al from the set of metadata. This field will
    /// capture all of the entries and their exact on-the-wire spelling
    /// and formatting.
    #[prost(string, optional, tag="4")]
    pub actual_grpcweb_trailers: ::core::option::Option<::prost::alloc::string::String>,
}
/// Describes one configuration for an RPC server. The server is
/// expected to expose the connectrpc.conformance.v1.ConformanceService
/// RPC service. The configuration does not include a port. The
/// process should pick an available port, which is typically
/// done by using port zero (0) when creating a network listener
/// so that the OS selects an available ephemeral port.
///
/// These properties are read from stdin. Once the server is
/// listening, details about the server, in the form of a
/// ServerCompatResponse, are written to stdout.
///
/// Each test process is expected to start only one RPC server.
/// When testing multiple configurations, multiple test processes
/// will be started, each with different properties.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerCompatRequest {
    /// Signals to the server that it must support at least this protocol. Note
    /// that it is fine to support others.
    /// For example if `PROTOCOL_CONNECT` is specified, the server _must_ support
    /// at least Connect, but _may_ also support gRPC or gRPC-web.
    #[prost(enumeration="Protocol", tag="1")]
    pub protocol: i32,
    /// Signals to the server the minimum HTTP version to support. As with
    /// `protocol`, it is fine to support other versions. For example, if
    /// `HTTP_VERSION_2` is specified, the server _must_ support HTTP/2, but _may_ also
    /// support HTTP/1.1 or HTTP/3.
    #[prost(enumeration="HttpVersion", tag="2")]
    pub http_version: i32,
    /// If true, generate a certificate that clients will be configured to trust
    /// when connecting and return it in the `pem_cert` field of the `ServerCompatResponse`.
    /// The certificate can be any TLS certificate where the subject matches the
    /// value sent back in the `host` field of the `ServerCompatResponse`.
    /// Self-signed certificates (and `localhost` as the subject) are allowed.
    /// If false, the server should not use TLS and instead use
    /// a plain-text/unencrypted socket.
    #[prost(bool, tag="4")]
    pub use_tls: bool,
    /// If non-empty, the clients will use certificates to authenticate
    /// themselves. This value is a PEM-encoded cert that should be
    /// trusted by the server. When non-empty, the server should require
    /// that clients provide certificates and they should validate that
    /// the certificate presented is valid.
    ///
    /// This will always be empty if use_tls is false.
    #[prost(bytes="vec", tag="5")]
    pub client_tls_cert: ::prost::alloc::vec::Vec<u8>,
    /// If non-zero, indicates the maximum size in bytes for a message.
    /// If the client sends anything larger, the server should reject it.
    #[prost(uint32, tag="6")]
    pub message_receive_limit: u32,
    /// If use_tls is true, this provides details for a self-signed TLS
    /// cert that the server may use.
    ///
    /// The provided certificate is only good for loopback communication:
    /// it uses "localhost" and "127.0.0.1" as the IP and DNS names in
    /// the certificate's subject. If the server needs a different subject
    /// or the client is in an environment where configuring trust of a
    /// self-signed certificate is difficult or infeasible.
    ///
    /// If the server implementation chooses to use these credentials,
    /// it must echo back the certificate in the ServerCompatResponse and
    /// should also leave the host field empty or explicitly set to
    /// "127.0.0.1".
    ///
    /// If it chooses to use a different certificate and key, it must send
    /// back the corresponding certificate in the ServerCompatResponse.
    #[prost(message, optional, tag="7")]
    pub server_creds: ::core::option::Option<TlsCreds>,
}
/// The outcome of one ServerCompatRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerCompatResponse {
    /// The host where the server is running. This should usually be `127.0.0.1`,
    /// unless your program actually starts a remote server to which the client
    /// should connect.
    #[prost(string, tag="1")]
    pub host: ::prost::alloc::string::String,
    /// The port where the server is listening.
    #[prost(uint32, tag="2")]
    pub port: u32,
    /// The TLS certificate, in PEM format, if `use_tls` was set
    /// to `true`. Clients will verify this certificate when connecting via TLS.
    /// If `use_tls` was set to `false`, this should always be empty.
    #[prost(bytes="vec", tag="3")]
    pub pem_cert: ::prost::alloc::vec::Vec<u8>,
}
/// TestSuite represents a set of conformance test cases. This is also the schema
/// used for the structure of a YAML test file. Each YAML file represents a test
/// suite, which can contain numerous cases. Each test suite has various properties
/// that indicate the kinds of features that are tested. Test suites may be skipped
/// based on whether the client or server under test implements these features.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestSuite {
    /// Test suite name. When writing test suites, this is a required field.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// The mode (client or server) that this test suite applies to. This is used
    /// in conjunction with the `--mode` flag passed to the conformance runner
    /// binary. If the mode on the suite is set to client, the tests will only be
    /// run if `--mode client` is set on the command to the test runner.
    /// Likewise if mode is server. If this is unset, the test case will be run in both modes.
    #[prost(enumeration="test_suite::TestMode", tag="2")]
    pub mode: i32,
    /// The actual test cases in the suite.
    #[prost(message, repeated, tag="3")]
    pub test_cases: ::prost::alloc::vec::Vec<TestCase>,
    /// If non-empty, the protocols to which this suite applies. If empty,
    /// this suite applies to all protocols.
    #[prost(enumeration="Protocol", repeated, tag="4")]
    pub relevant_protocols: ::prost::alloc::vec::Vec<i32>,
    /// If non-empty, the HTTP versions to which this suite applies. If empty,
    /// this suite applies to all HTTP versions.
    #[prost(enumeration="HttpVersion", repeated, tag="5")]
    pub relevant_http_versions: ::prost::alloc::vec::Vec<i32>,
    /// If non-empty, the codecs to which this suite applies. If empty, this
    /// suite applies to all codecs.
    #[prost(enumeration="Codec", repeated, tag="6")]
    pub relevant_codecs: ::prost::alloc::vec::Vec<i32>,
    /// If non-empty, the compression encodings to which this suite applies.
    /// If empty, this suite applies to all encodings.
    #[prost(enumeration="Compression", repeated, tag="7")]
    pub relevant_compressions: ::prost::alloc::vec::Vec<i32>,
    /// Indicates the Connect version validation behavior that this suite
    /// relies on.
    #[prost(enumeration="test_suite::ConnectVersionMode", tag="8")]
    pub connect_version_mode: i32,
    /// If true, the cases in this suite rely on TLS and will only be run against
    /// TLS server configurations.
    #[prost(bool, tag="9")]
    pub relies_on_tls: bool,
    /// If true, the cases in this suite rely on the client using TLS
    /// certificates to authenticate with the server. (Should only be
    /// true if relies_on_tls is also true.)
    #[prost(bool, tag="10")]
    pub relies_on_tls_client_certs: bool,
    /// If true, the cases in this suite rely on the Connect GET protocol.
    #[prost(bool, tag="11")]
    pub relies_on_connect_get: bool,
    /// If true, the cases in this suite rely on support for limiting the
    /// size of received messages. When true, mode should be set to indicate
    /// whether it is the client or the server that must support the limit.
    #[prost(bool, tag="12")]
    pub relies_on_message_receive_limit: bool,
}
/// Nested message and enum types in `TestSuite`.
pub mod test_suite {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TestMode {
        /// Used when the test suite does not apply to a particular mode. Such tests
        /// are run, regardless of the current test mode, to verify both clients and
        /// servers under test.
        Unspecified = 0,
        /// Indicates tests that are intended to be used only for a client-under-test.
        /// These cases can induce very particular and/or aberrant responses from the
        /// reference server, to verify how the client reacts to such responses.
        Client = 1,
        /// Indicates tests that are intended to be used only for a server-under-test.
        /// These cases can induce very particular and/or aberrant requests from the
        /// reference client, to verify how the server reacts to such requests.
        Server = 2,
    }
    impl TestMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TestMode::Unspecified => "TEST_MODE_UNSPECIFIED",
                TestMode::Client => "TEST_MODE_CLIENT",
                TestMode::Server => "TEST_MODE_SERVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TEST_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "TEST_MODE_CLIENT" => Some(Self::Client),
                "TEST_MODE_SERVER" => Some(Self::Server),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ConnectVersionMode {
        /// Used when the suite is agnostic to the server's validation
        /// behavior.
        Unspecified = 0,
        /// Used when the suite relies on the server validating the presence
        /// and correctness of the Connect version header or query param.
        Require = 1,
        /// Used when the suite relies on the server ignore any Connect
        /// header or query param.
        Ignore = 2,
    }
    impl ConnectVersionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConnectVersionMode::Unspecified => "CONNECT_VERSION_MODE_UNSPECIFIED",
                ConnectVersionMode::Require => "CONNECT_VERSION_MODE_REQUIRE",
                ConnectVersionMode::Ignore => "CONNECT_VERSION_MODE_IGNORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECT_VERSION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONNECT_VERSION_MODE_REQUIRE" => Some(Self::Require),
                "CONNECT_VERSION_MODE_IGNORE" => Some(Self::Ignore),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestCase {
    /// Defines the RPC that the client should invoke. The first eight fields
    /// are not fully specified. Instead the first field, test_name, must be
    /// present but is a prefix -- other characteristics that identify one
    /// permutation of the test case will be appended to this name. The next
    /// seven fields (http_version, protocol, codec, compression, host, port,
    /// and server_tls_cert) must not be present. They are all populated by
    /// the test harness based on the test environment (e.g. actual server and
    ///   port to use) and characteristics of a single permutation.
    #[prost(message, optional, tag="1")]
    pub request: ::core::option::Option<ClientCompatRequest>,
    /// To support extremely large messages, as well as very precisely-sized
    /// messages, without having to encode them fully or perfectly in YAML
    /// test cases, this value can be specified. When non-empty, this value
    /// should have no more entries than there are messages in the request
    /// stream. The first value is applied to the first request message, and
    /// so on. For each entry, if the size is present, it is used to expand
    /// the data field in the request (which is actually part of the response
    /// definition). The specified size is added to the current limit on
    /// message size that the server will accept. That sum is the size of the
    /// the serialized message that will be sent, and the data field will be
    /// padded as needed to reach that size.
    #[prost(message, repeated, tag="2")]
    pub expand_requests: ::prost::alloc::vec::Vec<test_case::ExpandedSize>,
    /// Defines the expected response to the above RPC. The expected response for
    /// a test is auto-generated based on the request details. The conformance runner
    /// will determine what the response should be according to the values specified
    /// in the test suite and individual test cases.
    ///
    /// This value can also be specified explicitly in the test case YAML. However,
    /// this is typically only needed for exception test cases. If the expected
    /// response is mostly re-stating the response definition that appears in the
    /// requests, test cases should rely on the auto-generation if possible.
    /// Otherwise, specifying an expected response can make the test YAML overly
    /// verbose and harder to read, write, and maintain.
    ///
    /// If the test induces behavior that prevents the server from sending or client
    /// from receiving the full response definition, it will be necessary to define
    /// the expected response explicitly. Timeouts, cancellations, and exceeding
    /// message size limits are good examples of this.
    ///
    /// Specifying an expected response explicitly in test definitions will override
    /// the auto-generation of the test runner.
    #[prost(message, optional, tag="3")]
    pub expected_response: ::core::option::Option<ClientResponseResult>,
    /// When expected_response indicates that an error is expected, in some cases, the
    /// actual error code returned may be flexible. In that case, this field provides
    /// other acceptable error codes, in addition to the one indicated in the
    /// expected_response. As long as the actual error's code matches any of these, the
    /// error is considered conformant, and the test case can pass.
    #[prost(enumeration="Code", repeated, tag="4")]
    pub other_allowed_error_codes: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `TestCase`.
pub mod test_case {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExpandedSize {
        /// The size, in bytes, relative to the limit. For example, to expand to a
        /// size that is exactly equal to the limit, this should be set to zero.
        /// Any value greater than zero indicates that the request size will be that
        /// many bytes over the limit.
        #[prost(int32, optional, tag="1")]
        pub size_relative_to_limit: ::core::option::Option<i32>,
    }
}
// @@protoc_insertion_point(module)
